"use strict";
/*
 * mavlink-message.ts
 *
 * Copyright (c) 2019,
 * Institute of Flight Mechanics and Control, University of Stuttgart.
 * Pascal Gro√ü <pascal.gross@ifr.uni-stuttgart.de>
 * All rights reserved.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */
Object.defineProperty(exports, "__esModule", { value: true });
function readUInt64LE(buffer, offset) {
    // adapted from https://github.com/dannycoates/int53
    offset = offset || 0;
    var low = buffer.readUInt32LE(offset);
    var high = buffer.readUInt32LE(offset + 4);
    return toDouble(high, low, false);
}
exports.readUInt64LE = readUInt64LE;
function readInt64LE(buffer, offset) {
    // adapted from https://github.com/dannycoates/int53
    offset = offset || 0;
    var low = buffer.readUInt32LE(offset);
    var high = buffer.readUInt32LE(offset + 4);
    return toDouble(high, low, true);
}
exports.readInt64LE = readInt64LE;
function writeInt64LE(buffer, value, offset) {
    offset = offset || 0;
    var hl = intHighLow(value);
    buffer.writeUInt32LE(hl[1], offset);
    buffer.writeUInt32LE(hl[0], offset + 4);
}
exports.writeInt64LE = writeInt64LE;
function writeUInt64LE(buffer, value, offset) {
    offset = offset || 0;
    var hl = uintHighLow(value);
    buffer.writeUInt32LE(hl[1], offset);
    buffer.writeUInt32LE(hl[0], offset + 4);
}
exports.writeUInt64LE = writeUInt64LE;
function intHighLow(value) {
    var MAX_UINT32 = 0x00000000FFFFFFFF;
    if (value > -1) {
        return uintHighLow(value);
    }
    var hl = uintHighLow(-value);
    var high = onesComplement(hl[0]);
    var low = onesComplement(hl[1]);
    if (low === MAX_UINT32) {
        high += 1;
        low = 0;
    }
    else {
        low += 1;
    }
    return [high, low];
}
function uintHighLow(value) {
    var MAX_UINT32 = 0x00000000FFFFFFFF;
    var MAX_INT53 = 0x001FFFFFFFFFFFFF;
    assert(function () { return value > -1 && value <= MAX_INT53; }, "number out of range");
    assert(function () { return Math.floor(value) === value; }, "number must be an integer");
    var high = 0;
    var signbit = value & 0xFFFFFFFF;
    var low = signbit < 0 ? (value & 0x7FFFFFFF) + 0x80000000 : signbit;
    if (value > MAX_UINT32) {
        high = (value - low) / (MAX_UINT32 + 1);
    }
    return [high, low];
}
function toDouble(high, low, signed) {
    // adapted from https://github.com/dannycoates/int53
    var MAX_UINT32 = 0x00000000FFFFFFFF;
    if (signed && (high & 0x80000000) !== 0) {
        high = onesComplement(high);
        low = onesComplement(low);
        assert(function () { return high < 0x00200000; }, "number too small");
        return -((high * (MAX_UINT32 + 1)) + low + 1);
    }
    else { //positive
        assert(function () { return high < 0x00200000; }, "number too large");
        return (high * (MAX_UINT32 + 1)) + low;
    }
}
function assert(test, message) {
    // adapted from https://github.com/dannycoates/int53
    if (!test)
        throw new Error(message);
}
function onesComplement(number) {
    // adapted from https://github.com/dannycoates/int53
    number = ~number;
    if (number < 0) {
        number = (number & 0x7FFFFFFF) + 0x80000000;
    }
    return number;
}
var MAVLinkMessage = /** @class */ (function () {
    function MAVLinkMessage(_system_id, _component_id) {
        this._system_id = _system_id;
        this._component_id = _component_id;
    }
    Object.defineProperty(MAVLinkMessage.prototype, "_payload_length", {
        get: function () {
            var length = 0;
            for (var _i = 0, _a = this._message_fields.filter(function (field) { return !field[2]; }); _i < _a.length; _i++) {
                var field = _a[_i];
                length += this.sizeof(field[1]);
            }
            return length;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MAVLinkMessage.prototype, "_extension_length", {
        get: function () {
            var length = 0;
            for (var _i = 0, _a = this._message_fields.filter(function (field) { return !field[2]; }); _i < _a.length; _i++) {
                var field = _a[_i];
                length += this.sizeof(field[1]);
            }
            return length;
        },
        enumerable: true,
        configurable: true
    });
    MAVLinkMessage.prototype.sizeof = function (type) {
        switch (type) {
            case "char":
            case "uint8_t":
            case "int8_t":
                return 1;
            case "uint16_t":
            case "int16_t":
                return 2;
            case "uint32_t":
            case "int32_t":
                return 4;
            case "int64_t":
            case "uint64_t":
                return 8;
            case "float":
                return 4;
            case "double":
                return 8;
            default:
                return 0;
        }
    };
    MAVLinkMessage.prototype.x25CRC = function (bytes) {
        var crc = 0xffff;
        bytes.forEach(function (b) {
            var tmp = (b & 0xff) ^ (crc & 0xff);
            tmp ^= tmp << 4;
            tmp &= 0xff;
            crc = (crc >> 8) ^ (tmp << 8) ^ (tmp << 3) ^ (tmp >> 4);
            crc &= 0xffff;
        });
        if (this._crc_extra) {
            var tmp = (this._crc_extra & 0xff) ^ (crc & 0xff);
            tmp ^= tmp << 4;
            tmp &= 0xff;
            crc = (crc >> 8) ^ (tmp << 8) ^ (tmp << 3) ^ (tmp >> 4);
            crc &= 0xffff;
        }
        return crc;
    };
    return MAVLinkMessage;
}());
exports.MAVLinkMessage = MAVLinkMessage;
//# sourceMappingURL=mavlink-message.js.map