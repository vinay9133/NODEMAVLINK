"use strict";
/*
 * mavlink-parser-v2.ts
 *
 * Copyright (c) 2019,
 * Institute of Flight Mechanics and Control, University of Stuttgart.
 * Pascal Gro√ü <pascal.gross@ifr.uni-stuttgart.de>
 * All rights reserved.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var mavlink_parser_base_1 = require("../mavlink-parser-base");
var mavlink_message_1 = require("../mavlink-message");
var MAVLinkParserV2 = /** @class */ (function (_super) {
    __extends(MAVLinkParserV2, _super);
    function MAVLinkParserV2() {
        var _this = _super.call(this) || this;
        _this.last_seq = 0;
        _this.start_marker = 0xFD;
        _this.minimum_packet_length = 12;
        return _this;
    }
    MAVLinkParserV2.prototype.calculate_packet_length = function (bytes) {
        return bytes.readUInt8(1) + this.minimum_packet_length;
    };
    MAVLinkParserV2.prototype.parseMessage = function (bytes) {
        var len = bytes.readUInt8(1);
        var incompat_flags = bytes.readUInt8(2);
        var compat_flags = bytes.readUInt8(3);
        var seq = bytes.readUInt8(4);
        var sysid = bytes.readUInt8(5);
        var compid = bytes.readUInt8(6);
        var msgid = bytes.readUIntLE(7, 3);
        if (bytes.length < len + this.minimum_packet_length)
            return undefined;
        var crc = bytes.readUInt16LE(len + this.minimum_packet_length - 2);
        var message;
        try {
            message = this.instantiateMessage(sysid, compid, msgid);
            var actual = message.x25CRC(bytes.slice(1, len + this.minimum_packet_length - 2));
            if (actual !== crc) {
                throw new Error("CRC error: expected " + crc + " but found " + actual + ".");
            }
            if (this.last_seq > 0 && this.last_seq + 1 !== seq) {
                throw new Error("Packet loss detected.");
            }
            if (bytes.length < this.minimum_packet_length + len) {
                throw new Error('Not enough bytes in buffer to parse the message.');
            }
            var payload = bytes.slice(this.minimum_packet_length - 2, len + this.minimum_packet_length - 2);
            var start = 0;
            for (var _i = 0, _a = message._message_fields; _i < _a.length; _i++) {
                var field = _a[_i];
                var field_name = field[0];
                var field_type = field[1];
                var extension_field = field[2];
                var field_length = message.sizeof(field_type);
                if (payload.length > start + field_length) {
                    message[field_name] = this.read(payload, start, field_type);
                    start += field_length;
                }
                else {
                    if (payload.readUInt8(start) === 0) { // payload truncation (last field was zero)
                        message[field_name] = 0;
                        start += field_length;
                    }
                    else { // append the truncated zero bytes so that we can parse the last field
                        var truncated = payload.slice(start);
                        var filler = Buffer.alloc(field_length - truncated.length);
                        var buf = Buffer.concat([truncated, filler]);
                        message[field_name] = this.read(buf, 0, field_type);
                        start += field_length;
                    }
                }
            }
            return message;
        }
        catch (e) {
            throw e;
        }
    };
    MAVLinkParserV2.prototype.read = function (bytes, start, type) {
        switch (type) {
            case "uint8_t":
                return bytes.readUInt8(start);
            case "uint16_t":
                return bytes.readUInt16LE(start);
            case "uint32_t":
                return bytes.readUInt32LE(start);
            case "uint64_t":
                return mavlink_message_1.readUInt64LE(bytes, start);
            case "int8_t":
                return bytes.readInt8(start);
            case "int16_t":
                return bytes.readInt16LE(start);
            case "int32_t":
                return bytes.readInt32LE(start);
            case "int64_t":
                return mavlink_message_1.readInt64LE(bytes, start);
            case "float":
                return bytes.readFloatLE(start);
            case "double":
                return bytes.readDoubleLE(start);
            case "char":
                return bytes.toString('ascii', start, 1);
        }
    };
    return MAVLinkParserV2;
}(mavlink_parser_base_1.MAVLinkParserBase));
exports.MAVLinkParserV2 = MAVLinkParserV2;
//# sourceMappingURL=mavlink-parser-v2.js.map